# -*- coding: utf-8 -*-
"""bfs_dfs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1flsOa0EHVQi0w63vBdYMsepa7sIAE32X
"""

from collections import deque

def breadth_first_search(problem):
    # Initialise the frontier as a queue (First-In, First-Out behaviour)
    frontier = deque([problem.initial])
    reached = set()  # A set to keep track of visited nodes
    reached.add(problem.initial)

    while frontier:
        # Remove the earliest added node (FIFO behaviour)
        node = frontier.popleft()

        # Check if the current node is the goal state
        if problem.is_goal(node):
            return node  # Return the goal node if found

        # Expand the current node and add unvisited children to the frontier
        for child in problem.expand(node):
            if child not in reached:
                reached.add(child)  # Mark the child node as visited
                frontier.append(child)  # Add the child to the queue (FIFO)

    return None  # Return failure if no solution is found

def depth_first_search(problem):
    # Initialise the frontier as a stack (Last-In, First-Out behaviour)
    frontier = [problem.initial]
    reached = set()  # A set to keep track of visited nodes
    reached.add(problem.initial)

    while frontier:
        # Remove the most recently added node (LIFO behaviour)
        node = frontier.pop()

        # Check if the current node is the goal state
        if problem.is_goal(node):
            return node  # Return the goal node if found

        # Expand the current node and add unvisited children to the frontier
        for child in problem.expand(node):
            if child not in reached:
                reached.add(child)  # Mark the child node as visited
                frontier.append(child)  # Add the child to the stack (LIFO)

    return None  # Return failure if no solution is found

class ExampleProblem:
    # Constructor to initialise the problem's data
    def __init__(self, initial, goal, graph):
        """
        :param initial: The starting node of the problem.
        :param goal: The target node to be found.
        :param graph: A dictionary representing the graph as an adjacency list.
        """
        self.initial = initial  # The initial state (starting node)
        self.goal = goal  # The goal state (target node)
        self.graph = graph  # The graph (adjacency list)

    # Method to check if a node is the goal
    def is_goal(self, node):
        """
        :param node: The current node to check.
        :return: True if the node is the goal, False otherwise.
        """
        return node == self.goal

    # Method to expand a node to its child nodes
    def expand(self, node):
        """
        :param node: The current node to expand.
        :return: A list of child nodes (neighbours).
        """
        return self.graph.get(node, [])  # Return the children or an empty list if none exist

# Example Graph (Adjacency List)
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F', 'G'],
    'D': [],
    'E': [],
    'F': [],
    'G': []
}

# Create an ExampleProblem instance
problem = ExampleProblem(initial='A', goal='F', graph=graph)

# Run BFS and DFS on the problem instance
print("BFS Result:", breadth_first_search(problem))
print("DFS Result:", depth_first_search(problem))

